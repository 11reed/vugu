package vugu

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"

	"github.com/vugu/vugu/internal/htmlx"
)

// Parse2 is an experiment...
// r is the actual input, fname is only used to emit line directives
func (p *ParserGo) Parse(r io.Reader, fname string) error {

	inRaw, err := ioutil.ReadAll(r)
	if err != nil {
		return err
	}

	// use a tokenizer to peek at the first element and see if it's an HTML tag
	isFullHTML := false
	tmpZ := htmlx.NewTokenizer(bytes.NewReader(inRaw))
	for {
		tt := tmpZ.Next()
		if tt == htmlx.ErrorToken {
			return tmpZ.Err()
		}
		if tt != htmlx.StartTagToken { // skip over non-tags
			continue
		}
		t := tmpZ.Token()
		if t.Data == "html" {
			isFullHTML = true
			break
		}
		break
	}

	log.Printf("isFullHTML: %v", isFullHTML)

	n, err := htmlx.Parse(bytes.NewReader(inRaw))
	if err != nil {
		return err
	}

	// err = htmlx.Render(os.Stdout, n)
	// if err != nil {
	// 	panic(err)
	// }

	// run n through the optimizer and convert large chunks of static elements into
	// vg-html attributes, this should provide a significiant performance boost for static HTML
	if !p.NoOptimizeStatic {
		err = compactNodeTree(n)
		if err != nil {
			return err
		}
	}

	var goBuf bytes.Buffer    // additional Go code (at top)
	var buildBuf bytes.Buffer // Build() method Go code (below)

	// var buildCSSBuf bytes.Buffer // CSS block
	// var buildJSBuf bytes.Buffer  // JS block
	var cssChunkList []codeChunk
	var jsChunkList []codeChunk

	fmt.Fprintf(&goBuf, "package %s\n\n", p.PackageName)
	fmt.Fprintf(&goBuf, "// DO NOT EDIT: This file was generated by vugu. Please regenerate instead of editing or add additional code in a separate file.\n\n")
	fmt.Fprintf(&goBuf, "import %q\n", "fmt")
	fmt.Fprintf(&goBuf, "import %q\n", "reflect")
	fmt.Fprintf(&goBuf, "import %q\n", "github.com/vugu/vugu")
	fmt.Fprintf(&goBuf, "import js %q\n", "github.com/vugu/vugu/js")
	fmt.Fprintf(&goBuf, "\n")

	// TODO: we use a prefix like "vg" as our namespace; should document that user code should not use that prefix to avoid conflicts
	fmt.Fprintf(&buildBuf, "func (c *%s) Build(vgin *vugu.BuildIn) (vgout *vugu.BuildOut, vgreterr error) {\n", p.StructType)
	fmt.Fprintf(&buildBuf, "    \n")
	fmt.Fprintf(&buildBuf, "    vgout = &vugu.BuildOut{}\n")
	fmt.Fprintf(&buildBuf, "    \n")
	fmt.Fprintf(&buildBuf, "    var vgn *vugu.VGNode\n")
	// fmt.Fprintf(&buildBuf, "    var vgparent *vugu.VGNode\n")

	didFirstNode := false

	var visit func(n *htmlx.Node) error
	visit = func(n *htmlx.Node) error {

		// log.Printf("n.Type = %v", n.Type)

		if n.Type == htmlx.DocumentNode {
			// nop
		} else if n.Type == htmlx.ElementNode && n.Data == "script" {

			// script tag, determine if it's JS or Go
			typeAttr := attrWithKey(n, "type")
			if typeAttr == nil || typeAttr.Val == "application/javascript" {
				for childN := n.FirstChild; childN != nil; childN = childN.NextSibling {
					if childN.Type != htmlx.TextNode {
						return fmt.Errorf("unexpected node type %v inside of script tag", childN.Type)
					}
					jsChunkList = append(jsChunkList, codeChunk{Line: childN.Line, Code: childN.Data})
				}
			} else if typeAttr.Val == "application/x-go" {
				for childN := n.FirstChild; childN != nil; childN = childN.NextSibling {
					if childN.Type != htmlx.TextNode {
						return fmt.Errorf("unexpected node type %v inside of script tag", childN.Type)
					}
					// if childN.Line > 0 {
					// 	fmt.Fprintf(&goBuf, "//line %s:%d\n", fname, childN.Line)
					// }
					goBuf.WriteString(childN.Data)
				}
			} else {
				return fmt.Errorf("unknown script type %q", typeAttr.Val)
			}

		} else if n.Type == htmlx.ElementNode && n.Data == "style" {

			// CSS
			for childN := n.FirstChild; childN != nil; childN = childN.NextSibling {
				if childN.Type != htmlx.TextNode {
					return fmt.Errorf("unexpected node type %v inside of style tag", childN.Type)
				}
				cssChunkList = append(cssChunkList, codeChunk{Line: childN.Line, Code: childN.Data})
			}

		} else {

			// vg-for
			if forx := vgForExprx(n); forx != "" {
				// fmt.Fprintf(&buildBuf, "for /*line %s:%d*/%s {\n", fname, n.Line, forx)
				fmt.Fprintf(&buildBuf, "for %s {\n", forx)
				defer fmt.Fprintf(&buildBuf, "}\n")
			}

			// vg-if

			if n.Type == htmlx.ElementNode && strings.Contains(n.Data, ":") {

				// component

				// dynamic attrs

				// component events

			} else {

				// regular element

				// if n.Line > 0 {
				// 	fmt.Fprintf(&buildBuf, "//line %s:%d\n", fname, n.Line)
				// }
				fmt.Fprintf(&buildBuf, "vgn = &vugu.VGNode{Type:vugu.VGNodeType(%d),Data:%q,Attr:%#v}\n", n.Type, n.Data, staticVGAttrx(n.Attr))
				if didFirstNode {
					fmt.Fprintf(&buildBuf, "vgparent.AppendChild(vgn)\n") // if not root, make AppendChild call
				}

				// dynamic attrs

				// vg-html

				// DOM events

			}

			didFirstNode = true

		}

		// if descending into a child we need to set the parent appropriately
		if n.FirstChild != nil {
			fmt.Fprintf(&buildBuf, "{\n")
			fmt.Fprintf(&buildBuf, "vgparent := vgn\n") // vgparent set for this block to vgn
			err := visit(n.FirstChild)
			if err != nil {
				return err
			}
			fmt.Fprintf(&buildBuf, "}\n")
		}

		// siblings don't need special handling, they can just add to the same parent
		if n.NextSibling != nil {
			err := visit(n.NextSibling)
			if err != nil {
				return err
			}
		}

		return nil
	}
	err = visit(n)
	if err != nil {
		return err
	}

	// TODO: walk n

	// const (
	// 	sectionNone int = iota
	// 	sectionEl
	// 	sectionGo
	// 	sectionCSS
	// 	sectionJS
	// )
	// section := sectionNone

	// z := htmlx.NewTokenizer(r)
	// for {
	// 	tt := z.Next()
	// 	if tt == htmlx.ErrorToken {
	// 		err := z.Err()
	// 		if err != nil && err != io.EOF {
	// 			return err
	// 		}
	// 		break
	// 	}
	// 	t := z.Token()

	// thisToken:
	// 	switch tt {

	// 	case htmlx.StartTagToken:

	// 		if section == sectionNone && t.DataAtom == atomx.Style {
	// 			if len(t.Attr) > 0 {
	// 				return fmt.Errorf("style tag with attribute(s) not supported")
	// 			}
	// 			section = sectionCSS
	// 			break thisToken
	// 		}

	// 	case htmlx.EndTagToken:

	// 		if section == sectionCSS {
	// 			section = sectionNone
	// 			break thisToken
	// 		}

	// 	case htmlx.TextToken:

	// 		if section == sectionCSS {
	// 			buildCSSBuf.WriteString(t.Data)
	// 			break thisToken
	// 		}

	// 	default:
	// 	}

	// }

	for _, chunk := range cssChunkList {
		// fmt.Fprintf(&buildBuf, "    out.AppendCSS(/*line %s:%d*/%q)\n\n", fname, chunk.Line, chunk.Code)
		fmt.Fprintf(&buildBuf, "    out.AppendCSS(%q)\n\n", chunk.Code)
	}

	for _, chunk := range jsChunkList {
		// fmt.Fprintf(&buildBuf, "    out.AppendJS(/*line %s:%d*/%q)\n\n", fname, chunk.Line, chunk.Code)
		fmt.Fprintf(&buildBuf, "    out.AppendJS(%q)\n\n", chunk.Code)
	}

	fmt.Fprintf(&buildBuf, "    return out, nil\n")
	fmt.Fprintf(&buildBuf, "}\n\n")

	var buf bytes.Buffer
	// log.Printf("goBuf.Len == %v", goBuf.Len())
	buf.Write(goBuf.Bytes())
	buf.Write(buildBuf.Bytes())

	outPath := filepath.Join(p.OutDir, p.OutFile)
	// err = ioutil.WriteFile(outPath, buf.Bytes(), 0644)
	// if err != nil {
	// 	return err
	// }

	fo, err := p.gofmt(buf.String())
	if err != nil {

		// if the gofmt errors, we still attempt to write out the non-fmt'ed output to the file, to assist in debugging
		ioutil.WriteFile(outPath, buf.Bytes(), 0644)

		return err
	}

	err = ioutil.WriteFile(outPath, []byte(fo), 0644)
	if err != nil {
		return err
	}

	return nil
}

func attrWithKey(n *htmlx.Node, key string) *htmlx.Attribute {
	for i := range n.Attr {
		if n.Attr[i].Key == key {
			return &n.Attr[i]
		}
	}
	return nil
}

type codeChunk struct {
	Line   int
	Column int
	Code   string
}
