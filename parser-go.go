package vugu

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"

	"github.com/vugu/vugu/internal/htmlx"
	"github.com/vugu/vugu/internal/htmlx/atom"
)

// Parse2 is an experiment...
// r is the actual input, fname is only used to emit line directives
func (p *ParserGo) Parse(r io.Reader, fname string) error {

	inRaw, err := ioutil.ReadAll(r)
	if err != nil {
		return err
	}

	// use a tokenizer to peek at the first element and see if it's an HTML tag
	isFullHTML := false
	tmpZ := htmlx.NewTokenizer(bytes.NewReader(inRaw))
	for {
		tt := tmpZ.Next()
		if tt == htmlx.ErrorToken {
			return tmpZ.Err()
		}
		if tt != htmlx.StartTagToken { // skip over non-tags
			continue
		}
		t := tmpZ.Token()
		if t.Data == "html" {
			isFullHTML = true
			break
		}
		break
	}

	log.Printf("isFullHTML: %v", isFullHTML)

	var docNodeList []*htmlx.Node

	if isFullHTML {

		n, err := htmlx.Parse(bytes.NewReader(inRaw))
		if err != nil {
			return err
		}
		docNodeList = append(docNodeList, n) // docNodeList is just this one item

	} else {

		nlist, err := htmlx.ParseFragment(bytes.NewReader(inRaw), &htmlx.Node{
			Type:     htmlx.ElementNode,
			DataAtom: atom.Div,
			Data:     "div",
		})
		if err != nil {
			return err
		}

		// only add elements
		for _, n := range nlist {
			if n.Type != htmlx.ElementNode {
				continue
			}
			docNodeList = append(docNodeList, n)
		}

		// // log.Printf("nlist = %#v", nlist)
		// for _, nl := range nlist {
		// 	log.Printf("nl.Data = %q", nl.Data)
		// }

		// if len(nlist) != 1 {
		// 	return fmt.Errorf("found %d fragment(s) instead of exactly 1", len(nlist))
		// }

		// n = nlist[0]

	}

	// err = htmlx.Render(os.Stdout, n)
	// if err != nil {
	// 	panic(err)
	// }

	// run n through the optimizer and convert large chunks of static elements into
	// vg-html attributes, this should provide a significiant performance boost for static HTML
	if !p.NoOptimizeStatic {
		for _, n := range docNodeList {
			err = compactNodeTree(n)
			if err != nil {
				return err
			}
		}
	}

	var goBuf bytes.Buffer    // additional Go code (at top)
	var buildBuf bytes.Buffer // Build() method Go code (below)

	// var buildCSSBuf bytes.Buffer // CSS block
	// var buildJSBuf bytes.Buffer  // JS block
	var cssChunkList []codeChunk
	var jsChunkList []codeChunk

	fmt.Fprintf(&goBuf, "package %s\n\n", p.PackageName)
	fmt.Fprintf(&goBuf, "// DO NOT EDIT: This file was generated by vugu. Please regenerate instead of editing or add additional code in a separate file.\n\n")
	fmt.Fprintf(&goBuf, "import %q\n", "fmt")
	fmt.Fprintf(&goBuf, "import %q\n", "reflect")
	fmt.Fprintf(&goBuf, "import %q\n", "github.com/vugu/vugu")
	fmt.Fprintf(&goBuf, "import js %q\n", "github.com/vugu/vugu/js")
	fmt.Fprintf(&goBuf, "\n")

	fmt.Fprintf(&goBuf, "// 'fix' unused imports\n")
	fmt.Fprintf(&goBuf, "var _ = fmt.Sprintf\n")
	fmt.Fprintf(&goBuf, "var _ = reflect.New\n")
	fmt.Fprintf(&goBuf, "var _ = js.ValueOf\n")
	fmt.Fprintf(&goBuf, "\n")

	// TODO: we use a prefix like "vg" as our namespace; should document that user code should not use that prefix to avoid conflicts
	fmt.Fprintf(&buildBuf, "func (c *%s) Build(vgin *vugu.BuildIn) (vgout *vugu.BuildOut, vgreterr error) {\n", p.StructType)
	fmt.Fprintf(&buildBuf, "    \n")
	fmt.Fprintf(&buildBuf, "    vgout = &vugu.BuildOut{}\n")
	fmt.Fprintf(&buildBuf, "    \n")
	fmt.Fprintf(&buildBuf, "    var vgn *vugu.VGNode\n")
	// fmt.Fprintf(&buildBuf, "    var vgparent *vugu.VGNode\n")

	didFirstNode := false

	var visit func(n *htmlx.Node) error
	visit = func(n *htmlx.Node) error {

		// log.Printf("n.Type = %v", n.Type)

		if n.Type == htmlx.DocumentNode {
			// nop
		} else if n.Type == htmlx.ElementNode && n.Data == "script" {

			// script tag, determine if it's JS or Go
			typeAttr := attrWithKey(n, "type")
			if typeAttr == nil || typeAttr.Val == "application/javascript" {
				for childN := n.FirstChild; childN != nil; childN = childN.NextSibling {
					if childN.Type != htmlx.TextNode {
						return fmt.Errorf("unexpected node type %v inside of script tag", childN.Type)
					}
					jsChunkList = append(jsChunkList, codeChunk{Line: childN.Line, Code: childN.Data})
				}
			} else if typeAttr.Val == "application/x-go" {
				for childN := n.FirstChild; childN != nil; childN = childN.NextSibling {
					if childN.Type != htmlx.TextNode {
						return fmt.Errorf("unexpected node type %v inside of script tag", childN.Type)
					}
					// if childN.Line > 0 {
					// 	fmt.Fprintf(&goBuf, "//line %s:%d\n", fname, childN.Line)
					// }
					goBuf.WriteString(childN.Data)
				}
			} else {
				return fmt.Errorf("unknown script type %q", typeAttr.Val)
			}

			// for script, this is it we're done with the visit
			return nil

		} else if n.Type == htmlx.ElementNode && n.Data == "style" {

			// CSS
			for childN := n.FirstChild; childN != nil; childN = childN.NextSibling {
				if childN.Type != htmlx.TextNode {
					return fmt.Errorf("unexpected node type %v inside of style tag", childN.Type)
				}
				cssChunkList = append(cssChunkList, codeChunk{Line: childN.Line, Code: childN.Data})
			}

			// for style, this is it we're done with the visit
			return nil

		} else {

			// group the processing of this one node into a func so the defer's are called before moving onto the next sibling
			err := func() error {

				// vg-for
				if forx := vgForExprx(n); forx != "" {
					// fmt.Fprintf(&buildBuf, "for /*line %s:%d*/%s {\n", fname, n.Line, forx)
					fmt.Fprintf(&buildBuf, "for %s {\n", forx)
					defer fmt.Fprintf(&buildBuf, "}\n")
				}

				// vg-if
				ife := vgIfExprx(n)
				if ife != "" {
					fmt.Fprintf(&buildBuf, "if %s {\n", ife)
					defer fmt.Fprintf(&buildBuf, "}\n")
				}

				if n.Type == htmlx.ElementNode && strings.Contains(n.Data, ":") {

					// component

					// dynamic attrs

					// component events

				} else {

					// regular element

					// if n.Line > 0 {
					// 	fmt.Fprintf(&buildBuf, "//line %s:%d\n", fname, n.Line)
					// }
					fmt.Fprintf(&buildBuf, "vgn = &vugu.VGNode{Type:vugu.VGNodeType(%d),Data:%q,Attr:%#v}\n", n.Type, n.Data, staticVGAttrx(n.Attr))
					if didFirstNode {
						fmt.Fprintf(&buildBuf, "vgparent.AppendChild(vgn)\n") // if not root, make AppendChild call
					} else {
						fmt.Fprintf(&buildBuf, "vgout.Doc = vgn // Doc root for output\n") // for first element we need to assign as Doc on BuildOut
					}

					// dynamic attrs
					dynExprMap, dynExprMapKeys := dynamicVGAttrExprx(n)
					for _, k := range dynExprMapKeys {
						valExpr := dynExprMap[k]
						fmt.Fprintf(&buildBuf, "vgn.Attr = append(vgn.Attr, vugu.VGAttribute{Key:%q,Val:fmt.Sprint(%s)})\n", k, valExpr)
					}

					// vg-html
					htmlExpr := vgHTMLExprx(n)
					if htmlExpr != "" {
						fmt.Fprintf(&buildBuf, "{\nvghtml := %s; \nvgn.InnerHTML = &vghtml\n}\n", htmlExpr)
					}

					// DOM events
					// vgDOMEventExprs()

				}

				didFirstNode = true

				return nil
			}()
			if err != nil {
				return err
			}

		}

		// if descending into a child we need to set the parent appropriately
		if n.FirstChild != nil {
			fmt.Fprintf(&buildBuf, "{\n")
			fmt.Fprintf(&buildBuf, "vgparent := vgn; _ = vgparent\n") // vgparent set for this block to vgn
			err := visit(n.FirstChild)
			if err != nil {
				return err
			}
			fmt.Fprintf(&buildBuf, "}\n")
		}

		// siblings don't need special handling, they can just add to the same parent
		if n.NextSibling != nil {
			err := visit(n.NextSibling)
			if err != nil {
				return err
			}
		}

		return nil
	}

	for _, n := range docNodeList {
		err = visit(n)
		if err != nil {
			return err
		}
	}

	// TODO: walk n

	// const (
	// 	sectionNone int = iota
	// 	sectionEl
	// 	sectionGo
	// 	sectionCSS
	// 	sectionJS
	// )
	// section := sectionNone

	// z := htmlx.NewTokenizer(r)
	// for {
	// 	tt := z.Next()
	// 	if tt == htmlx.ErrorToken {
	// 		err := z.Err()
	// 		if err != nil && err != io.EOF {
	// 			return err
	// 		}
	// 		break
	// 	}
	// 	t := z.Token()

	// thisToken:
	// 	switch tt {

	// 	case htmlx.StartTagToken:

	// 		if section == sectionNone && t.DataAtom == atomx.Style {
	// 			if len(t.Attr) > 0 {
	// 				return fmt.Errorf("style tag with attribute(s) not supported")
	// 			}
	// 			section = sectionCSS
	// 			break thisToken
	// 		}

	// 	case htmlx.EndTagToken:

	// 		if section == sectionCSS {
	// 			section = sectionNone
	// 			break thisToken
	// 		}

	// 	case htmlx.TextToken:

	// 		if section == sectionCSS {
	// 			buildCSSBuf.WriteString(t.Data)
	// 			break thisToken
	// 		}

	// 	default:
	// 	}

	// }

	for _, chunk := range cssChunkList {
		// fmt.Fprintf(&buildBuf, "    out.AppendCSS(/*line %s:%d*/%q)\n\n", fname, chunk.Line, chunk.Code)
		fmt.Fprintf(&buildBuf, "    out.AppendCSS(%q)\n\n", chunk.Code)
	}

	for _, chunk := range jsChunkList {
		// fmt.Fprintf(&buildBuf, "    out.AppendJS(/*line %s:%d*/%q)\n\n", fname, chunk.Line, chunk.Code)
		fmt.Fprintf(&buildBuf, "    out.AppendJS(%q)\n\n", chunk.Code)
	}

	fmt.Fprintf(&buildBuf, "    return vgout, nil\n")
	fmt.Fprintf(&buildBuf, "}\n\n")

	var buf bytes.Buffer
	// log.Printf("goBuf.Len == %v", goBuf.Len())
	buf.Write(goBuf.Bytes())
	buf.Write(buildBuf.Bytes())

	outPath := filepath.Join(p.OutDir, p.OutFile)
	// err = ioutil.WriteFile(outPath, buf.Bytes(), 0644)
	// if err != nil {
	// 	return err
	// }

	fo, err := p.gofmt(buf.String())
	if err != nil {

		// if the gofmt errors, we still attempt to write out the non-fmt'ed output to the file, to assist in debugging
		ioutil.WriteFile(outPath, buf.Bytes(), 0644)

		return err
	}

	err = ioutil.WriteFile(outPath, []byte(fo), 0644)
	if err != nil {
		return err
	}

	return nil
}

func attrWithKey(n *htmlx.Node, key string) *htmlx.Attribute {
	for i := range n.Attr {
		if n.Attr[i].Key == key {
			return &n.Attr[i]
		}
	}
	return nil
}

type codeChunk struct {
	Line   int
	Column int
	Code   string
}
