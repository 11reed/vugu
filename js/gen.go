// +build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// Code-generate as much of this package as possible using local Go installation source.
func main() {

	b, err := exec.Command("go", "env", "GOROOT").CombinedOutput()
	if err != nil {
		panic(err)
	}
	goroot := strings.TrimSpace(string(b))

	log.Printf("Using GOROOT %s", goroot)

	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, filepath.Join(goroot, "src/syscall/js"), nil, 0)
	if err != nil {
		panic(err)
	}
	pkg := pkgs["js"]
	if pkg == nil {
		panic("unable to find js package after parse")
	}

	// build constraints
	// js
	// !js

	// log.Printf("pkg: %#v", pkg)

	for fname, f := range pkg.Files {

		baseName := filepath.Base(fname)
		if baseName == "doc.go" || baseName == "gen.go" || strings.HasSuffix(baseName, "_test.go") {
			continue
		}

		inSrcBytes, err := ioutil.ReadFile(filepath.Join(goroot, "src/syscall/js", baseName))
		if err != nil {
			panic(err)
		}

		jsF, err := os.OpenFile(strings.TrimSuffix(baseName, ".go")+"-js.go", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
		if err != nil {
			panic(err)
		}
		defer jsF.Close()

		nonJsF, err := os.OpenFile(strings.TrimSuffix(baseName, ".go")+"-nonjs.go", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
		if err != nil {
			panic(err)
		}
		defer nonJsF.Close()

		fmt.Fprintf(jsF, "// +build js\n\npackage js\n\n")
		fmt.Fprintf(jsF, "// WARNING: DO NOT EDIT. This file is generated by gen.go via go generate.\n\n")
		fmt.Fprintf(jsF, "import sjs \"syscall/js\"\n\n")

		fmt.Fprintf(nonJsF, "// +build !js\n\npackage js\n\n")
		fmt.Fprintf(nonJsF, "// WARNING: DO NOT EDIT. This file is generated by gen.go via go generate.\n\n")

		// exported types:

		for _, decl := range f.Decls {
			// log.Printf("decl: %#v", decl)
			gd, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}
			// log.Printf("gd: %#v", gd)

			if len(gd.Specs) != 1 {
				continue
			}

			ts, ok := gd.Specs[0].(*ast.TypeSpec)
			// if !ok || ts.Name == nil || !isExported(ts.Name.Name) {
			if !ok || ts.Name == nil || !ts.Name.IsExported() {
				continue
			}

			log.Printf("ts: %#v; Name=%s", ts, ts.Name.Name)

			switch t := ts.Type.(type) {
			case *ast.StructType:
				log.Printf("StructType: %v", t)
				log.Printf("StructType: pos=%v, end=%v", t.Pos(), t.End())

				text := inSrcBytes[fset.Position(t.Pos()).Offset:fset.Position(t.End()).Offset]

				log.Printf("text: %s\n", text)

			case *ast.InterfaceType:
			case *ast.Ident:
			default:
				panic(fmt.Errorf("unknown TypeSpec.Type %T: %#v", ts.Type, ts.Type))
			}

			// check out ast.Inspect !

			// for js, we define the type as an alias of the syscal/js type
			// for non-js, we copy the type definition

		}

		// exported funcs:
		// loop over each func (includes funcs with or without method receiver)
		// for _, decl := range f.Decls {
		// 	// log.Printf("decl: %#v", decl)
		// 	fd, ok := decl.(*ast.FuncDecl)
		// 	if !ok {
		// 		continue
		// 	}
		// 	if fd.Name == nil {
		// 		continue
		// 	}
		// 	if !isExported(fd.Name.Name) {
		// 		continue
		// 	}
		// 	log.Printf("func name %q", fd.Name.Name)
		// }

	}

}

// func isExported(name string) bool {
// 	if name == "" {
// 		return false
// 	}
// 	return unicode.IsUpper(rune(name[0]))
// }
